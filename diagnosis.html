<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="viewport-fit=cover, width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#37A7C4">
    <title>PhysioCare - Analyse & Diagnostic</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/tailwindcss/2.2.19/tailwind.min.css" rel="stylesheet">
    <script src="js/storage-manager.js"></script>
    <script src="js/managers.js"></script>
    <!-- Le CSS reste inchangé, je continue avec le HTML et JS modifié -->
</head>
<body class="min-h-screen">
    <!-- Le HTML reste inchangé jusqu'au script -->
    <script>
        const CONFIG = {
            api: 'https://physiocare-api.b00135522.workers.dev',
            storage: {
                keys: {
                    diagnosis: 'patient_diagnosis',
                    personalInfo: 'patient_personal_info',
                    activity: 'patient_physical_activity',
                    symptoms: 'patient_symptoms',
                    documents: 'patient_documents'
                }
            },
            retries: {
                maxAttempts: 3,
                baseDelay: 1000,
                maxDelay: 10000
            },
            timeouts: {
                request: 30000,
                global: 60000
            }
        };

        class DiagnosticManager {
            constructor() {
                this.storage = StorageManager;
                this.abortController = null;
                this.pendingRequests = new Set();
                this.initializeElements();
                this.setupEventListeners();
            }

            initializeElements() {
                this.sections = {
                    remarks: document.getElementById('remarksSection'),
                    loading: document.getElementById('loadingSection'),
                    results: document.getElementById('resultsSection'),
                    validation: document.getElementById('validationSection')
                };
                
                this.elements = {
                    diagnosticResults: document.getElementById('diagnosticResults'),
                    remarksInput: document.getElementById('remarks'),
                    startButton: document.getElementById('startAnalysis'),
                    validationButton: document.querySelector('.validation-button'),
                    secondaryValidationButton: document.querySelector('.validation-button.secondary')
                };

                Object.entries(this.sections).forEach(([key, element]) => {
                    if (!element) throw new Error(`Section ${key} manquante`);
                });
                
                Object.entries(this.elements).forEach(([key, element]) => {
                    if (!element) throw new Error(`Élément ${key} manquant`);
                });
            }

            setupEventListeners() {
                this.elements.startButton.addEventListener('click', 
                    () => this.handleStartAnalysis());

                this.elements.validationButton.addEventListener('click',
                    () => this.handleValidationClick());

                this.elements.secondaryValidationButton.addEventListener('click',
                    () => this.handleSecondaryValidationClick());

                window.addEventListener('unload', () => this.destroy());
            }

            async handleStartAnalysis() {
                try {
                    this.showLoading();
                    const data = await this.gatherPatientData();
                    Logger.debug('Analysis', 'Données collectées', data);
                    
                    const diagnosis = await this.requestDiagnosisWithRetry(data);
                    Logger.debug('Analysis', 'Diagnostic reçu', diagnosis);
                    
                    await this.displayAndSaveResults(diagnosis);
                } catch (error) {
                    Logger.error('Analysis', 'Erreur analyse', error);
                    this.handleError(error);
                }
            }

            async gatherPatientData() {
                try {
                    const documents = await this.storage.loadDocuments();
                    const validDocs = documents.filter(doc => 
                        this.storage.validateDocument(doc));
                    
                    Logger.debug('Documents', `${validDocs.length}/${documents.length} documents valides`);
                    
                    return {
                        personalInfo: this.loadStorageData('patient_personal_info'),
                        physicalActivity: this.loadStorageData('patient_physical_activity'),
                        symptoms: this.loadStorageData('patient_symptoms'),
                        documents: validDocs,
                        remarks: this.elements.remarksInput.value.trim()
                    };
                } catch (error) {
                    Logger.error('Data', 'Erreur collecte', error);
                    throw error;
                }
            }

            async requestDiagnosisWithRetry(data, attempt = 0) {
                try {
                    this.abortController = new AbortController();
                    this.pendingRequests.add(this.abortController);

                    const response = await Promise.race([
                        fetch(CONFIG.api, {
                            method: 'POST',
                            signal: this.abortController.signal,
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ type: 'diagnosis', data })
                        }),
                        new Promise((_, reject) => 
                            setTimeout(() => reject(new Error('Timeout')), CONFIG.timeouts.request)
                        )
                    ]);

                    if (!response.ok) {
                        const error = await response.text();
                        throw new Error(`API Error: ${response.status} - ${error}`);
                    }

                    const result = await response.json();
                    return this.validateDiagnosticResponse(result);

                } catch (error) {
                    if (error.name === 'AbortError') {
                        throw new Error('Requête annulée');
                    }

                    if (attempt < CONFIG.retries.maxAttempts - 1) {
                        const delay = Math.min(
                            CONFIG.retries.baseDelay * Math.pow(2, attempt),
                            CONFIG.retries.maxDelay
                        );
                        await new Promise(resolve => setTimeout(resolve, delay));
                        return this.requestDiagnosisWithRetry(data, attempt + 1);
                    }

                    throw error;
                } finally {
                    this.pendingRequests.delete(this.abortController);
                }
            }

            validateDiagnosticResponse(response) {
                const diagnoses = response.diagnostics || response.diagnoses;
                
                if (!Array.isArray(diagnoses) || !diagnoses.length) {
                    throw new Error('Réponse invalide: pas de diagnostic');
                }

                diagnoses.forEach(diagnostic => {
                    const required = ['name', 'probability', 'shortDescription', 'details'];
                    required.forEach(field => {
                        if (!(field in diagnostic)) {
                            throw new Error(`Diagnostic invalide: ${field} manquant`);
                        }
                    });

                    if (!Array.isArray(diagnostic.details)) {
                        throw new Error('Diagnostic invalide: details incorrects');
                    }
                });

                return { diagnoses };
            }

            async displayAndSaveResults(data) {
                this.sections.loading.classList.add('hidden');
                this.elements.diagnosticResults.innerHTML = '';

                data.diagnoses.forEach(diagnostic => {
                    const element = this.createDiagnosticElement(diagnostic);
                    this.elements.diagnosticResults.appendChild(element);
                });

                this.sections.results.classList.remove('hidden');
                this.sections.validation.classList.remove('hidden');

                await this.saveResults();
                Logger.debug('UI', 'Résultats affichés et sauvegardés');
            }

            createDiagnosticElement(diagnostic) {
                const element = document.createElement('div');
                element.className = `diagnostic-item ${
                    diagnostic.probability >= 80 ? 'primary' : ''}`;
                element.innerHTML = this.getDiagnosticTemplate(diagnostic);
                return element;
            }

            getDiagnosticTemplate(diagnostic) {
                return `
                    <div class="flex justify-between items-start">
                        <div>
                            <h3 class="font-semibold text-lg">
                                ${this.sanitizeString(diagnostic.name)}
                            </h3>
                            <p class="text-sm opacity-70">
                                ${this.sanitizeString(diagnostic.shortDescription)}
                            </p>
                        </div>
                        <span class="font-semibold">${diagnostic.probability}%</span>
                    </div>
                    <div class="probability-bar">
                        <div class="probability-bar-fill" 
                             style="width: ${diagnostic.probability}%">
                        </div>
                    </div>
                    <button class="expand-button" onclick="window.diagnosticManager.toggleDetails(this)">
                        Voir les détails
                        <svg class="w-5 h-5 transform transition-transform duration-200" 
                             fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" 
                                  stroke-width="2" d="M19 9l-7 7-7-7"/>
                        </svg>
                    </button>
                    <div class="diagnostic-details">
                        ${diagnostic.details.map(detail => `
                            <div class="details-section">
                                <h4 class="font-medium mb-2">
                                    ${this.sanitizeString(detail.title)}
                                </h4>
                                <p class="text-sm opacity-80">
                                    ${this.sanitizeString(detail.content)}
                                </p>
                            </div>
                        `).join('')}
                    </div>
                `;
            }

            toggleDetails(button) {
                const details = button.nextElementSibling;
                const expanded = !details.classList.contains('expanded');
                details.classList.toggle('expanded');
                
                const arrow = button.querySelector('svg');
                arrow.style.transform = expanded ? 'rotate(180deg)' : '';
            }

            async saveResults() {
                try {
                    const data = {
                        remarks: this.elements.remarksInput.value.trim(),
                        diagnoses: Array.from(this.elements.diagnosticResults.children)
                            .map(this.extractDiagnosticData.bind(this))
                            .filter(Boolean)
                    };

                    if (!data.diagnoses.length) {
                        throw new Error('Aucun diagnostic à sauvegarder');
                    }

                    await Storage.save(CONFIG.storage.keys.diagnosis, data);
                    Logger.debug('Storage', 'Résultats sauvegardés');
                    return true;
                } catch (error) {
                    Logger.error('Storage', 'Erreur sauvegarde', error);
                    return false;
                }
            }

            extractDiagnosticData(element) {
                try {
                    return {
                        name: element.querySelector('h3')?.textContent?.trim(),
                        probability: parseInt(
                            element.querySelector('.probability-bar-fill')
                                ?.style.width?.replace('%', '') || '0'
                        ),
                        shortDescription: element.querySelector('p.opacity-70')
                            ?.textContent?.trim(),
                        details: Array.from(element.querySelectorAll('.details-section'))
                            .map(section => ({
                                title: section.querySelector('h4')?.textContent?.trim(),
                                content: section.querySelector('p')?.textContent?.trim()
                            }))
                            .filter(detail => detail.title && detail.content)
                    };
                } catch (error) {
                    Logger.error('Data', 'Erreur extraction diagnostic', error);
                    return null;
                }
            }

            loadStorageData(key) {
                try {
                    const data = localStorage.getItem(key);
                    return data ? JSON.parse(data) : {};
                } catch {
                    return {};
                }
            }

            sanitizeString(str) {
                if (!str || typeof str !== 'string') return '';
                return str.trim().replace(/[<>]/g, '');
            }

            showLoading() {
                this.sections.remarks.classList.add('hidden');
                this.sections.loading.classList.remove('hidden');
            }

            handleError(error) {
                this.sections.loading.classList.add('hidden');
                this.sections.remarks.classList.remove('hidden');
                
                const errorDiv = document.createElement('div');
                errorDiv.className = 
                    'bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded relative mb-4';
                errorDiv.innerHTML = `
                    <strong class="font-bold">Erreur!</strong>
                    <span class="block sm:inline">
                        ${this.sanitizeString(error.message)}
                    </span>
                `;
                
                this.sections.remarks.insertBefore(
                    errorDiv,
                    this.sections.remarks.firstChild
                );
                
                setTimeout(() => errorDiv.remove(), 5000);
            }

            async handleValidationClick() {
                try {
                    if (await this.saveResults()) {
                        window.location.href = 'treatment.html';
                    } else {
                        throw new Error('Erreur sauvegarde résultats');
                    }
                } catch (error) {
                    this.handleError(error);
                }
            }

            handleSecondaryValidationClick() {
                this.sections.results.classList.add('hidden');
                this.sections.validation.classList.add('hidden');
                this.sections.remarks.classList.remove('hidden');
            }

            destroy() {
                this.abortController?.abort();
                this.pendingRequests.forEach(req => req.abort());
                this.pendingRequests.clear();

                const buttons = [
                    this.elements.startButton,
                    this.elements.validationButton,
                    this.elements.secondaryValidationButton
                ];

                buttons.forEach(button => {
                    if (button) {
                        button.removeEventListener('click', () => this.handleStartAnalysis);
                        button.removeEventListener('click', () => this.handleValidationClick);
                        button.removeEventListener('click', () => this.handleSecondaryValidationClick);
                    }
                });

                window.removeEventListener('unload', () => this.destroy);
                Logger.debug('Lifecycle', 'Instance détruite');
            }
        }

        // Initialisation
        document.addEventListener('DOMContentLoaded', () => {
            window.diagnosticManager = new DiagnosticManager();
            
            // Chargement des données précédentes
            const savedData = Storage.load(CONFIG.storage.keys.diagnosis);
            if (savedData?.diagnoses?.length) {
                window.diagnosticManager.displayAndSaveResults(savedData);
                Logger.debug('Init', 'Données précédentes chargées');
            }

            Logger.debug('Init', 'DiagnosticManager initialisé');
        });
    </script>
</body>
</html>
